// –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–µ–Ω–∏—Ç–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞: gokens-bot/src/bot.js

require("./instrument.js");

const Sentry = require("@sentry/node");

try {
  foo();
} catch (e) {
  Sentry.captureException(e);
}

const { Telegraf, Markup } = require('telegraf');
const express = require('express');
const { Connection, PublicKey, LAMPORTS_PER_SOL, Keypair } = require('@solana/web3.js');
require('dotenv').config();

// ===== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =====
const BOT_TOKEN = process.env.BOT_TOKEN || '8236253203:AAGTFLqMxz1ygQFaep6p0y1zGANsSDAcqYg';
const SOLANA_RPC = process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com';
const FRONTEND_URL = process.env.FRONTEND_URL || 'https://gokens-web.netlify.app';
const PROGRAM_ID = process.env.PROGRAM_ID || 'FeLQB1uPtHA7wfq2m1uBHxd4SL8G5H37S9LbTEh5DmRh';

// ===== EXPRESS –°–ï–†–í–ï–† –î–õ–Ø HEALTH CHECK =====
const app = express();
app.use(express.json());

app.get('/healthz', (req, res) => {
  res.status(200).json({ 
    status: 'healthy',
    uptime: process.uptime(),
    timestamp: new Date().toISOString()
  });
});

const PORT = process.env.PORT || 8080;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`‚úÖ Health check server running on port ${PORT}`);
});

// ===== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ë–û–¢–ê =====
const bot = new Telegraf(BOT_TOKEN);
const connection = new Connection(SOLANA_RPC, 'confirmed');

// ===== –•–†–ê–ù–ò–õ–ò–©–ï –°–ï–°–°–ò–ô =====
const userSessions = new Map();

// –î–µ–º–æ –¥–∞–Ω–Ω—ã–µ –¥–ª—è NFT
const artNFTs = [
  { id: 1, name: 'Digital Mona Lisa', price: 4.89, artist: '@wzard', description: 'A masterpiece reimagined for the digital age' },
  { id: 2, name: 'Abstract Reality', price: 3.21, artist: '@vzla', description: 'Where dreams meet blockchain' },
  { id: 3, name: 'Neon Dreams', price: 5.67, artist: '@neon', description: 'Cyberpunk aesthetic NFT' },
  { id: 4, name: 'Cosmic Journey', price: 8.99, artist: '@cosmos', description: 'Travel through the stars' }
];

const gameAssets = [
  { id: 1, name: 'Legendary Sword', game: 'MetaQuest', price: 0.5, rarity: 'Legendary' },
  { id: 2, name: 'Dragon Mount', game: 'CryptoRealm', price: 2.3, rarity: 'Epic' },
  { id: 3, name: 'Space Station', game: 'StarVerse', price: 15.0, rarity: 'Mythic' }
];

// ===== MIDDLEWARE =====
bot.use(async (ctx, next) => {
  if (ctx.from) {
    if (!userSessions.has(ctx.from.id)) {
      userSessions.set(ctx.from.id, {
        walletAddress: null,
        walletConnected: false,
        balance: 0,
        portfolio: {
          artNFTs: [],
          gameAssets: [],
          fractionalTokens: []
        },
        kycVerified: false,
        language: 'en'
      });
    }
  }
  return next();
});

// ===== –ö–û–ú–ê–ù–î–ê START =====
bot.start(async (ctx) => {
  const userName = ctx.from.first_name || 'User';
  const userId = ctx.from.id;
  
  const welcomeMessage = `
üé® *Welcome to Gokens Bot, ${userName}!* üéÆ

Your gateway to tokenized art and gaming assets on Solana blockchain.

üåü *Features:*
‚Ä¢ Connect wallet & manage portfolio
‚Ä¢ Buy/Sell NFTs directly in Telegram  
‚Ä¢ Fractional art ownership
‚Ä¢ Real-time price tracking
‚Ä¢ Jupiter token swaps

üìä *Platform Stats:*
‚Ä¢ Network: Solana Devnet
‚Ä¢ Total Volume: 32,456 SOL
‚Ä¢ Active Users: 12,543
‚Ä¢ NFTs Created: 50,234

Choose an action below to get started:`;

  await ctx.replyWithMarkdown(
    welcomeMessage,
    Markup.inlineKeyboard([
      [Markup.button.callback('üí≥ Connect Wallet', 'connect_wallet')],
      [Markup.button.callback('üé® Browse Art', 'browse_art'), 
       Markup.button.callback('üéÆ Game Assets', 'browse_games')],
      [Markup.button.callback('üíº My Portfolio', 'view_portfolio')],
      [Markup.button.callback('üí± Swap Tokens', 'swap_tokens')],
      [Markup.button.callback('üìä Platform Stats', 'view_stats')],
      [Markup.button.callback('‚úÖ KYC Verification', 'kyc_verify')],
      [Markup.button.url('üåê Open Web App', FRONTEND_URL)]
    ])
  );
});

// ===== –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö–û–®–ï–õ–¨–ö–ê =====
bot.action('connect_wallet', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–æ—à–µ–ª–µ–∫ –¥–ª—è –¥–µ–º–æ
  const tempKeypair = Keypair.generate();
  const walletAddress = tempKeypair.publicKey.toString();
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Å–µ—Å—Å–∏–∏
  session.walletAddress = walletAddress;
  session.walletConnected = true;
  
  // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å (–¥–ª—è –¥–µ–º–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π)
  const demoBalance = (Math.random() * 10 + 1).toFixed(4);
  session.balance = parseFloat(demoBalance);
  
  const connectUrl = `${FRONTEND_URL}?connect=${walletAddress}&telegram=${userId}`;
  
  await ctx.editMessageText(
    `‚úÖ *Wallet Connected Successfully!*\n\n` +
    `üìç *Address:*\n\`${walletAddress.substring(0, 20)}...\n...${walletAddress.substring(walletAddress.length - 20)}\`\n\n` +
    `üí∞ *Balance:* ${demoBalance} SOL\n` +
    `üåê *Network:* Solana Devnet\n` +
    `üì± *Program ID:* \`${PROGRAM_ID.substring(0, 8)}...\`\n\n` +
    `üí° *Tip:* You can also connect your real Phantom wallet on the website.`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîó Connect Phantom Wallet', url: connectUrl }],
          [{ text: 'üíº View Portfolio', callback_data: 'view_portfolio' }],
          [{ text: 'üé® Browse NFTs', callback_data: 'browse_art' }],
          [{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]
        ]
      }
    }
  );
  await ctx.answerCbQuery('Wallet connected! You can now browse and buy NFTs.');
});

// ===== –ü–†–û–°–ú–û–¢–† –ü–û–†–¢–§–ï–õ–Ø =====
bot.action('view_portfolio', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  if (!session.walletConnected) {
    await ctx.answerCbQuery('Please connect your wallet first!', { show_alert: true });
    return;
  }
  
  // –°–∏–º—É–ª—è—Ü–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è
  const totalValue = session.balance * 100.25; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è —Ü–µ–Ω–∞ SOL –≤ USD
  const profit = (Math.random() * 20 - 10).toFixed(2);
  
  await ctx.editMessageText(
    `üíº *Your Portfolio*\n\n` +
    `üìç *Wallet:* \`${session.walletAddress.substring(0, 12)}...\`\n` +
    `üí∞ *Balance:* ${session.balance.toFixed(4)} SOL\n\n` +
    `üé® *Art NFTs:* ${session.portfolio.artNFTs.length}\n` +
    `üéÆ *Game Assets:* ${session.portfolio.gameAssets.length}\n` +
    `üî¢ *Fractional Tokens:* ${session.portfolio.fractionalTokens.length}\n\n` +
    `üìà *Total Value:* $${totalValue.toFixed(2)} USD\n` +
    `üìä *24h Change:* ${profit > 0 ? '+' : ''}${profit}%\n` +
    `‚úÖ *KYC Status:* ${session.kycVerified ? 'Verified' : 'Not Verified'}`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîÑ Refresh', callback_data: 'view_portfolio' }],
          [{ text: 'üí± Swap Tokens', callback_data: 'swap_tokens' }],
          [{ text: 'üìú Transaction History', callback_data: 'view_history' }],
          [{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]
        ]
      }
    }
  );
  await ctx.answerCbQuery();
});

// ===== –ü–†–û–°–ú–û–¢–† NFT –ò–°–ö–£–°–°–¢–í–ê =====
bot.action('browse_art', async (ctx) => {
  let message = 'üé® *Available Art NFTs*\n\n';
  const keyboard = [];
  
  artNFTs.forEach((nft, index) => {
    message += `${index + 1}. *${nft.name}*\n`;
    message += `   Artist: ${nft.artist}\n`;
    message += `   Price: ${nft.price} SOL\n`;
    message += `   _${nft.description}_\n\n`;
    
    keyboard.push([{ 
      text: `Buy "${nft.name}" - ${nft.price} SOL`, 
      callback_data: `buy_art_${nft.id}` 
    }]);
  });
  
  keyboard.push(
    [{ text: 'üñº View Gallery', url: `${FRONTEND_URL}#gallery` }],
    [{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]
  );
  
  await ctx.editMessageText(message, {
    parse_mode: 'Markdown',
    reply_markup: { inline_keyboard: keyboard }
  });
  await ctx.answerCbQuery();
});

// ===== –ü–†–û–°–ú–û–¢–† –ò–ì–†–û–í–´–• –ê–ö–¢–ò–í–û–í =====
bot.action('browse_games', async (ctx) => {
  let message = 'üéÆ *Gaming Assets Marketplace*\n\n';
  const keyboard = [];
  
  gameAssets.forEach((asset, index) => {
    const rarityEmoji = asset.rarity === 'Mythic' ? 'üî•' : 
                        asset.rarity === 'Legendary' ? '‚≠ê' : 'üíé';
    
    message += `${index + 1}. *${asset.name}* ${rarityEmoji}\n`;
    message += `   Game: ${asset.game}\n`;
    message += `   Rarity: ${asset.rarity}\n`;
    message += `   Price: ${asset.price} SOL\n\n`;
    
    keyboard.push([{ 
      text: `Buy "${asset.name}" - ${asset.price} SOL`, 
      callback_data: `buy_game_${asset.id}` 
    }]);
  });
  
  keyboard.push([{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]);
  
  await ctx.editMessageText(message, {
    parse_mode: 'Markdown',
    reply_markup: { inline_keyboard: keyboard }
  });
  await ctx.answerCbQuery();
});

// ===== –ü–û–ö–£–ü–ö–ê NFT =====
bot.action(/buy_(art|game)_(\d+)/, async (ctx) => {
  const [, type, id] = ctx.match;
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  if (!session.walletConnected) {
    await ctx.answerCbQuery('Please connect your wallet first!', { show_alert: true });
    return;
  }
  
  const item = type === 'art' 
    ? artNFTs.find(n => n.id === parseInt(id))
    : gameAssets.find(a => a.id === parseInt(id));
  
  if (!item) {
    await ctx.answerCbQuery('Item not found!', { show_alert: true });
    return;
  }
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
  if (session.balance < item.price) {
    await ctx.answerCbQuery(`Insufficient balance! You need ${item.price} SOL`, { show_alert: true });
    return;
  }
  
  // –°–∏–º—É–ª–∏—Ä—É–µ–º –ø–æ–∫—É–ø–∫—É
  const txHash = Keypair.generate().publicKey.toString().substring(0, 44);
  
  await ctx.editMessageText(
    `‚úÖ *Purchase Initiated!*\n\n` +
    `üì¶ *Item:* ${item.name}\n` +
    `üí∞ *Price:* ${item.price} SOL\n` +
    `üìç *Type:* ${type === 'art' ? 'Art NFT' : 'Game Asset'}\n\n` +
    `üîÑ *Transaction Status:* Processing...\n` +
    `üîó *TX Hash:* \`${txHash}\`\n\n` +
    `‚è± Estimated time: 5-10 seconds\n\n` +
    `_The NFT will be transferred to your wallet after confirmation._`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üìú View on Solscan', url: `https://solscan.io/tx/${txHash}?cluster=devnet` }],
          [{ text: 'üíº View Portfolio', callback_data: 'view_portfolio' }],
          [{ text: 'üõí Continue Shopping', callback_data: type === 'art' ? 'browse_art' : 'browse_games' }],
          [{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]
        ]
      }
    }
  );
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—Ç—Ñ–µ–ª—å
  if (type === 'art') {
    session.portfolio.artNFTs.push(item);
  } else {
    session.portfolio.gameAssets.push(item);
  }
  session.balance -= item.price;
  
  await ctx.answerCbQuery(`Successfully initiated purchase of ${item.name}!`);
});

// ===== SWAP –¢–û–ö–ï–ù–û–í =====
bot.action('swap_tokens', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  if (!session.walletConnected) {
    await ctx.answerCbQuery('Please connect your wallet first!', { show_alert: true });
    return;
  }
  
  const message = `
üí± *Token Swap (Jupiter Integration)*

Available pairs:
‚Ä¢ SOL ‚ÜîÔ∏è USDC
‚Ä¢ SOL ‚ÜîÔ∏è GOKENS  
‚Ä¢ USDC ‚ÜîÔ∏è GOKENS

üìä *Current Rates:*
‚Ä¢ 1 SOL = 100.25 USDC
‚Ä¢ 1 SOL = 667 GOKENS
‚Ä¢ 1 GOKENS = 0.15 USDC

üí∞ *Your Balance:*
‚Ä¢ SOL: ${session.balance.toFixed(4)}
‚Ä¢ USDC: 0.00
‚Ä¢ GOKENS: 0.00

Select a swap pair:`;

  await ctx.editMessageText(message, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'SOL ‚Üí USDC', callback_data: 'swap_sol_usdc' },
         { text: 'SOL ‚Üí GOKENS', callback_data: 'swap_sol_gokens' }],
        [{ text: 'USDC ‚Üí SOL', callback_data: 'swap_usdc_sol' },
         { text: 'GOKENS ‚Üí SOL', callback_data: 'swap_gokens_sol' }],
        [{ text: 'üåê Use Jupiter on Web', url: `${FRONTEND_URL}#swap` }],
        [{ text: 'üîô Back', callback_data: 'view_portfolio' }]
      ]
    }
  });
  await ctx.answerCbQuery();
});

// ===== –û–ë–†–ê–ë–û–¢–ö–ê –°–í–ê–ü–û–í =====
bot.action(/swap_(\w+)_(\w+)/, async (ctx) => {
  const [, from, to] = ctx.match;
  
  await ctx.editMessageText(
    `üîÑ *Swap ${from.toUpperCase()} ‚Üí ${to.toUpperCase()}*\n\n` +
    `To complete the swap, please use our web interface.\n` +
    `Jupiter aggregator will find the best rates for you.`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üåê Complete Swap on Website', url: `${FRONTEND_URL}#swap` }],
          [{ text: 'üîô Back', callback_data: 'swap_tokens' }]
        ]
      }
    }
  );
  await ctx.answerCbQuery('Opening swap interface...', { show_alert: true });
});

// ===== KYC –í–ï–†–ò–§–ò–ö–ê–¶–ò–Ø =====
bot.action('kyc_verify', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  if (session.kycVerified) {
    await ctx.editMessageText(
      `‚úÖ *KYC Already Verified!*\n\n` +
      `Your account is fully verified and you have access to all features.`,
      {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]
          ]
        }
      }
    );
    await ctx.answerCbQuery('Already verified!');
    return;
  }
  
  await ctx.editMessageText(
    `üõ° *KYC Verification*\n\n` +
    `Complete KYC to unlock:\n` +
    `‚Ä¢ Higher transaction limits\n` +
    `‚Ä¢ Access to exclusive NFTs\n` +
    `‚Ä¢ Fractional ownership features\n` +
    `‚Ä¢ Priority support\n\n` +
    `The process takes only 2 minutes.`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üìù Start Verification', callback_data: 'kyc_start' }],
          [{ text: 'üåê Verify on Website', url: `${FRONTEND_URL}#kyc` }],
          [{ text: 'üîô Back', callback_data: 'back_to_menu' }]
        ]
      }
    }
  );
  await ctx.answerCbQuery();
});

// ===== –ù–ê–ß–ê–õ–û KYC =====
bot.action('kyc_start', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  // –°–∏–º—É–ª–∏—Ä—É–µ–º –±—ã—Å—Ç—Ä—É—é –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é –¥–ª—è –¥–µ–º–æ
  session.kycVerified = true;
  
  await ctx.editMessageText(
    `‚úÖ *KYC Verification Complete!*\n\n` +
    `Congratulations! Your account is now fully verified.\n\n` +
    `*Verification Level:* Basic\n` +
    `*Status:* Approved\n` +
    `*Valid Until:* Dec 31, 2025\n\n` +
    `You now have access to all platform features!`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üíº View Portfolio', callback_data: 'view_portfolio' }],
          [{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]
        ]
      }
    }
  );
  await ctx.answerCbQuery('Verification successful!', { show_alert: true });
});

// ===== –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ü–õ–ê–¢–§–û–†–ú–´ =====
bot.action('view_stats', async (ctx) => {
  const stats = {
    totalVolume: '32,456 SOL',
    dailyVolume: '1,234 SOL',
    activeUsers: '12,543',
    nftsCreated: '50,234',
    gamesIntegrated: '25',
    topCollection: 'Gokens Genesis',
    topGame: 'MetaQuest'
  };
  
  const message = `
üìä *Gokens Platform Statistics*

üìà *Volume:*
‚Ä¢ Total: ${stats.totalVolume}
‚Ä¢ 24h: ${stats.dailyVolume}
‚Ä¢ 24h Change: +12.5%

üë• *Users & Activity:*
‚Ä¢ Active Users: ${stats.activeUsers}
‚Ä¢ NFTs Created: ${stats.nftsCreated}
‚Ä¢ Games Integrated: ${stats.gamesIntegrated}

üèÜ *Top Performers:*
‚Ä¢ Collection: ${stats.topCollection}
‚Ä¢ Game: ${stats.topGame}
‚Ä¢ Most Traded: Digital Mona Lisa

‚ö° *Network Stats:*
‚Ä¢ Blockchain: Solana
‚Ä¢ Avg TX Time: <1 second
‚Ä¢ Avg Fee: 0.00025 SOL
‚Ä¢ Success Rate: 99.9%`;

  await ctx.editMessageText(message, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üîÑ Refresh', callback_data: 'view_stats' }],
        [{ text: 'üìä View Charts on Web', url: `${FRONTEND_URL}#stats` }],
        [{ text: 'üîô Main Menu', callback_data: 'back_to_menu' }]
      ]
    }
  });
  await ctx.answerCbQuery();
});

// ===== –ò–°–¢–û–†–ò–Ø –¢–†–ê–ù–ó–ê–ö–¶–ò–ô =====
bot.action('view_history', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  const message = `
üìú *Transaction History*

${session.portfolio.artNFTs.length > 0 || session.portfolio.gameAssets.length > 0 ? 
  session.portfolio.artNFTs.concat(session.portfolio.gameAssets)
    .slice(-5)
    .map((item, i) => `${i + 1}. Bought "${item.name}" for ${item.price} SOL`)
    .join('\n') 
  : '_No transactions yet_'}

View full history on the website.`;

  await ctx.editMessageText(message, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üåê View on Website', url: `${FRONTEND_URL}#history` }],
        [{ text: 'üîô Back', callback_data: 'view_portfolio' }]
      ]
    }
  });
  await ctx.answerCbQuery();
});

// ===== –í–û–ó–í–†–ê–¢ –í –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ =====
bot.action('back_to_menu', async (ctx) => {
  await ctx.editMessageText(
    'üé® *Gokens Bot* üéÆ\n\nChoose an action:',
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [Markup.button.callback('üí≥ Connect Wallet', 'connect_wallet')],
          [Markup.button.callback('üé® Browse Art', 'browse_art'), 
           Markup.button.callback('üéÆ Game Assets', 'browse_games')],
          [Markup.button.callback('üíº My Portfolio', 'view_portfolio')],
          [Markup.button.callback('üí± Swap Tokens', 'swap_tokens')],
          [Markup.button.callback('üìä Platform Stats', 'view_stats')],
          [Markup.button.callback('‚úÖ KYC Verification', 'kyc_verify')],
          [Markup.button.url('üåê Open Web App', FRONTEND_URL)]
        ]
      }
    }
  );
  await ctx.answerCbQuery();
});

// ===== –ö–û–ú–ê–ù–î–ê HELP =====
bot.command('help', async (ctx) => {
  await ctx.reply(
    `*Gokens Bot Commands:*\n\n` +
    `/start - Main menu\n` +
    `/wallet - Wallet info\n` +
    `/portfolio - View your portfolio\n` +
    `/stats - Platform statistics\n` +
    `/help - This help message\n\n` +
    `*Support:* @gokens_support\n` +
    `*Website:* ${FRONTEND_URL}`,
    { parse_mode: 'Markdown' }
  );
});

// ===== –ö–û–ú–ê–ù–î–ê WALLET =====
bot.command('wallet', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  if (!session.walletConnected) {
    await ctx.reply('Wallet not connected. Use /start to connect.');
    return;
  }
  
  await ctx.replyWithMarkdown(
    `üí≥ *Wallet Info*\n\n` +
    `Address: \`${session.walletAddress.substring(0, 20)}...\`\n` +
    `Balance: ${session.balance.toFixed(4)} SOL\n` +
    `Network: Solana Devnet`
  );
});

// ===== –ö–û–ú–ê–ù–î–ê PORTFOLIO =====
bot.command('portfolio', async (ctx) => {
  const userId = ctx.from.id;
  const session = userSessions.get(userId);
  
  if (!session.walletConnected) {
    await ctx.reply('Please connect your wallet first. Use /start');
    return;
  }
  
  await ctx.replyWithMarkdown(
    `üíº *Portfolio Summary*\n\n` +
    `Art NFTs: ${session.portfolio.artNFTs.length}\n` +
    `Game Assets: ${session.portfolio.gameAssets.length}\n` +
    `Balance: ${session.balance.toFixed(4)} SOL`
  );
});

// ===== –ö–û–ú–ê–ù–î–ê STATS =====
bot.command('stats', async (ctx) => {
  await ctx.replyWithMarkdown(
    `üìä *Quick Stats*\n\n` +
    `Total Volume: 32,456 SOL\n` +
    `Active Users: 12,543\n` +
    `NFTs: 50,234\n\n` +
    `Use /start for detailed statistics.`
  );
});

// ===== –û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô =====
bot.on('text', async (ctx) => {
  const text = ctx.message.text.toLowerCase();
  
  if (text.includes('price') || text.includes('cost')) {
    await ctx.reply('To view NFT prices, use /start and browse our collections.');
  } else if (text.includes('buy') || text.includes('purchase')) {
    await ctx.reply('To buy NFTs, use /start and browse available items.');
  } else if (text.includes('sell')) {
    await ctx.reply('To sell NFTs, please use our web platform: ' + FRONTEND_URL);
  } else {
    await ctx.reply('I didn\'t understand that. Try /help for available commands.');
  }
});

// ===== –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö =====
bot.catch((err, ctx) => {
  console.error(`Error for ${ctx.updateType}:`, err);
  ctx.reply('An error occurred. Please try again or contact support.');
});

// ===== –ó–ê–ü–£–°–ö –ë–û–¢–ê =====
bot.launch({
  dropPendingUpdates: true
}).then(() => {
  console.log('ü§ñ Gokens Bot is running!');
  console.log('üìç Program ID:', PROGRAM_ID);
  console.log('üåê Frontend:', FRONTEND_URL);
  console.log('‚ö° Network:', SOLANA_RPC);
}).catch(err => {
  console.error('Failed to start bot:', err);
  process.exit(1);
});

// ===== GRACEFUL SHUTDOWN =====
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));

console.log('Bot initialization complete. Waiting for messages...');